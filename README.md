# 3DRenderer_Cpp
Software+Hardware 3D Renderer/Rasterizer in C++!

## Introduction
This game engine is created using C++ with all of the code required for basic 3D rendering and game logic written from scratch. Environments are composed of GameObjects which form a basic structure that is used to build with and allow for encapsulation of the core rendering components which allows for easy deployment of scenes.
## Use of OOP (Object Oriented Programming)
In previous iterations of the project, rendering is done through function calls. They set up the model, pass arguments through the linear algebra functions to set up the view and projection matrices and transform them to view space to be displayed on screen. The only concern is that for many objects in scene, we have to do that for every single object, so we use OOP to streamline and modularize the project for larger scenes, inspired by Unity's GameObject and Scene system.
## The GameObject
GameObjects form a fundamental unit for all objects in the engine. They contains code for essential components such as the Camera, MeshRenderer, Object Transforms and other relevant code. At its core, it consists of three basic components:
An ObjectTransform which represents its position, rotation and scale in three-dimensional euclidian space.
Virtual methods for Start() which is called once and Update() for each frame rendered. It can be expanded easily to support more functions such as collision detection through inheritance.
Additional GameObject components that can be inherited.
## Rendering
Objects are rendered with a five stage graphic pipeline that can be expandable.
Objects are broken up into triangles.
Objects are transformed from Model Space (The span of points usually between (-1,-1,-1) to (1,1,1) normalized, pre-generated by a 3D modelling application such as Blender or Maya.) to a position in world space specified in the GameObject's Transform through transformation matrices.
Those points ae then transformed into the camera's point of view using a view matrix.
Finally those points are transformed into normalized screen-space (0,1) using a Projection Matrix and plotted as triangle points to a fragement shader that renders each triangle into frame using barycentric interpolation.
